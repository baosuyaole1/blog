import{_ as a,c as l,o as e,N as i}from"./chunks/framework.294d0221.js";const q=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"view/GC算法/GC算法.md"}'),t={name:"view/GC算法/GC算法.md"},o=i('<h2 id="gc常见算法" tabindex="-1">GC常见算法 <a class="header-anchor" href="#gc常见算法" aria-label="Permalink to &quot;GC常见算法&quot;">​</a></h2><blockquote><p>垃圾收集(Garbage Collection) 通常被称为&quot;GC&quot;</p></blockquote><h3 id="引用计数法" tabindex="-1">引用计数法 <a class="header-anchor" href="#引用计数法" aria-label="Permalink to &quot;引用计数法&quot;">​</a></h3><ul><li><p>每个对象有一个引用计数属性，新增一个引用时计数加1，引用释放时计数减1，计数为0时可以回收。</p><h4 id="优缺点" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><ul><li>可以即时回收垃圾对象</li><li>减少程序的卡顿时间</li><li>无法回收循环引用的对象</li><li>资源消耗较大</li></ul></li></ul><h3 id="标记-清除法" tabindex="-1">标记-清除法 <a class="header-anchor" href="#标记-清除法" aria-label="Permalink to &quot;标记-清除法&quot;">​</a></h3><ul><li><p>&quot;标记-清除&quot;(Mark-Sweep)算法，如它的名字一样，算法分为&quot;标记&quot;和&quot;清除&quot;两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收掉所有被标记的对象。之所以说它是最基础的收集算法，是因为后续的收集算法都是基于这种思路并对其缺点进行改进而得到的</p></li><li><p>它的主要缺点有两个：一个是效率问题，标记和清除过程的效率都不高；另外一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致，当程序在以后的运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</p><h4 id="优缺点-1" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-1" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><ul><li>可以回收循环引用的对象</li><li>容易产生碎片化空间，浪费空间</li><li>不会立即回收垃圾对象</li></ul></li></ul><h3 id="标记整理算法" tabindex="-1">标记整理算法 <a class="header-anchor" href="#标记整理算法" aria-label="Permalink to &quot;标记整理算法&quot;">​</a></h3><ul><li><p>标记整理可以看做是标记清除的增强</p></li><li><p>标记阶段的操作和标记清除一致，遍历所以对象将当前活动的可达对象进行标记。</p></li><li><p>清除阶段会先执行整理，移动对象位置。</p><h4 id="优缺点-2" tabindex="-1">优缺点 <a class="header-anchor" href="#优缺点-2" aria-label="Permalink to &quot;优缺点&quot;">​</a></h4><ul><li><p>减少碎片化空间</p></li><li><p>不会立即回收垃圾对象</p></li></ul></li></ul>',8),r=[o];function u(h,n,c,s,d,p){return e(),l("div",null,r)}const b=a(t,[["render",u]]);export{q as __pageData,b as default};
