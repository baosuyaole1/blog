import{_ as l,c as a,o as i,N as e}from"./chunks/framework.294d0221.js";const b=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"view/GC算法/V8引擎.md"}'),o={name:"view/GC算法/V8引擎.md"},r=e('<h3 id="认识v8" tabindex="-1">认识V8 <a class="header-anchor" href="#认识v8" aria-label="Permalink to &quot;认识V8&quot;">​</a></h3><ol><li>V8是一款主流的Javascript执行引擎</li><li>V8采用即时编译</li><li>V8内存设限</li></ol><h4 id="v8垃圾回收策略" tabindex="-1">V8垃圾回收策略 <a class="header-anchor" href="#v8垃圾回收策略" aria-label="Permalink to &quot;V8垃圾回收策略&quot;">​</a></h4><ol><li>采用分代回收的思想</li><li>内存分为新生代、老生代</li><li>针对不同的对象采用不同算法</li></ol><h5 id="v8中常用的gc算法" tabindex="-1">V8中常用的GC算法 <a class="header-anchor" href="#v8中常用的gc算法" aria-label="Permalink to &quot;V8中常用的GC算法&quot;">​</a></h5><ol><li>分代回收</li><li>空间复制</li><li>标记清除</li><li>标记整理</li><li>标记增量</li></ol><h3 id="v8如何回收新生代对象" tabindex="-1">V8如何回收新生代对象 <a class="header-anchor" href="#v8如何回收新生代对象" aria-label="Permalink to &quot;V8如何回收新生代对象&quot;">​</a></h3><h4 id="v8内存分配" tabindex="-1">V8内存分配 <a class="header-anchor" href="#v8内存分配" aria-label="Permalink to &quot;V8内存分配&quot;">​</a></h4><ol><li>V8内存空间一分为二</li><li>小空间用于存储新生代对象（32M|16M）</li><li>新生代指的是存活时间较短的对象</li></ol><h4 id="v8新生代对象回收实现" tabindex="-1">V8新生代对象回收实现 <a class="header-anchor" href="#v8新生代对象回收实现" aria-label="Permalink to &quot;V8新生代对象回收实现&quot;">​</a></h4><ol><li>回收过程采用复制算法+标记整理</li><li>新生代内存区分为两个等大小空间</li><li>使用空间Form，空闲空间为To</li><li>活动对象存储于Form空间</li><li>标记整理后将活动对象拷贝至To</li><li>Form与To交换空间完成释放</li></ol><h5 id="回收细节说明" tabindex="-1">回收细节说明 <a class="header-anchor" href="#回收细节说明" aria-label="Permalink to &quot;回收细节说明&quot;">​</a></h5><ol><li>拷贝过程中可能出现晋升</li><li>晋升就是将新生代对象移至老生代</li><li>一轮GC还存活的新生代需要晋升</li><li>To空间的使用率超过25%</li></ol><h3 id="v8如何回收老生代对象" tabindex="-1">V8如何回收老生代对象 <a class="header-anchor" href="#v8如何回收老生代对象" aria-label="Permalink to &quot;V8如何回收老生代对象&quot;">​</a></h3><h4 id="老年代对象说明" tabindex="-1">老年代对象说明 <a class="header-anchor" href="#老年代对象说明" aria-label="Permalink to &quot;老年代对象说明&quot;">​</a></h4><ol><li>老年代对象存放在右侧老生代区域</li><li>64位操作系统1.4G，32操作系统700M</li><li>老年对象就是值存活时间较长的对象</li></ol><h4 id="老年代对象回收实现" tabindex="-1">老年代对象回收实现 <a class="header-anchor" href="#老年代对象回收实现" aria-label="Permalink to &quot;老年代对象回收实现&quot;">​</a></h4><ol><li>主要采用标记清除、标记整理、增量标记算法</li><li>首先使用标记清除完成垃圾空间的回收</li><li>采用标记整理进行空间优化</li><li>采用增量标记进行效率优化</li></ol><h4 id="细节对比" tabindex="-1">细节对比 <a class="header-anchor" href="#细节对比" aria-label="Permalink to &quot;细节对比&quot;">​</a></h4><ol><li>新生代区域垃圾回收使用空间换时间</li><li>老生代区域垃圾回收不适合复制算法</li></ol>',20),t=[r];function h(n,d,c,s,_,u){return i(),a("div",null,t)}const m=l(o,[["render",h]]);export{b as __pageData,m as default};
